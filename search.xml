<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F22%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[面向对象的三大特性 封装 继承 多态 原型链的知识原型链是面向对象的基础，是非常重要的部分。有以下几种知识： 创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new 运算符 创建对象有几种方法方式一：字面量12var obj11 = &#123;name: 'smyh'&#125;;var obj12 = new Object(name: `smyh`); //内置对象（内置的构造函数） 上面的两种写法，效果是一样的。因为，第一种写法，obj11会指向Object。 第一种写法是：字面量的方式。 第二种写法是：内置的构造函数 方式二：通过构造函数1234var M = function (name) &#123; this.name = name;&#125;var obj3 = new M('smyhvae'); 方法三：Object.create12var p = &#123;name:'smyhvae'&#125;;var obj3 = Object.create(p); //此方法创建的对象，是用原型链连接的 第三种方法，很少有人能说出来。这种方式里，obj3是实例，p是obj3的原型（name是p原型里的属性），构造函数是Objecet 。 原型、构造函数、实例，以及原型链 PS：任何一个函数，如果在前面加了new，那就是构造函数。 原型、构造函数、实例三者之间的关系 1、构造函数通过 new 生成实例 2、构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性） 3、原型对象中有 constructor，指向该原型的构造函数。 上面的三行，代码演示： 12345var Foo = function (name) &#123; this.name = name;&#125;var fn = new Foo(&apos;smyhvae&apos;); 上面的代码中，Foo.prototype.constructor === Foo的结果是true： 4、实例的__proto__指向原型。也就是说，Foo.__proto__ === M.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。 Foo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。 原型链原型链的基本原理：任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。 Object是原型链的顶端。 原型可以起到继承的作用。原型里的方法都可以被不同的实例共享： 1234//给Foo的原型添加 say 函数Foo.prototype.say = function () &#123; console.log(&apos;&apos;);&#125; 原型链的关键：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。 instanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。 instanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。 注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。 注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。 比如说： foo instance of Foo的结果为true，因为foo.__proto__ === M.prototype为true。 foo instance of Objecet的结果也为true，因为Foo.prototype.__proto__ === Object.prototype为true。 但我们不能轻易的说：foo 一定是 由Object创建的实例。这句话是错误的。我们来看下一个问题就明白了。 分析一个问题问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？ 分析：这就要用到原型的constructor属性了。 foo.__proto__.constructor === M的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。 new 运算符当new Foo()时发生了什么： （1）创建一个新的空对象实例。 （2）将此空对象的隐式原型指向其构造函数的显示原型。 （3）执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。 （4）如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。 参考《JS高程》6.2.2 类继承和原型继承的区别12]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域通信]]></title>
    <url>%2F2018%2F04%2F22%2F%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[面试问题前端通信类的问题，主要包括以下内容： 什么是同源策略及限制(3点) 前后端如何通信 如何创建Ajax 跨域通信的几种方式 面试参考答案同源策略的概念和具体限制同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释） 具体解释：（1）源包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则源不同，那就是跨域了。（2）限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住） Cookie、LocalStorage和IndexDB无法获取。 无法获取和操作DOM。 不能发送Ajax请求。我们要注意，Ajax只适合同源的通信。 前后端如何通信主要有以下几种方式： Ajax：不支持跨域。 WebSocket：不受同源策略的限制，支持跨域。 CORS：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的Ajax。 如何创建Ajax在回答 Ajax 的问题时，要回答以下几个方面： 1、XMLHttpRequest 的工作原理 2、兼容性处理（XMLHttpRequest只有在高级浏览器中才支持,在回答问题时，这个兼容性问题不要忽略） 3、事件的触发条件 4、事件的触发顺序（XMLHttpRequest有很多触发事件，每个事件是怎么触发的） 发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）（1）创建XMLHttpRequest 对象。（2）使用open方法设置请求的参数。open(method, url, 是否异步)。（3）发送请求。（4）注册事件。注册onreadystatechange事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。（5）获取返回的数据，更新UI。 发送 get 请求和 post 请求get请求举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type="button" value="发送get_ajax请求" id='btnAjax'&gt;&lt;script type="text/javascript"&gt; // 绑定点击事件 document.querySelector('#btnAjax').onclick = function () &#123; // 发送ajax 请求 需要 五步 // （1）创建异步对象 var ajaxObj = new XMLHttpRequest(); // （2）设置请求的参数。包括：请求的方法、请求的url。 ajaxObj.open('get', '02-ajax.php'); // （3）发送请求 ajaxObj.send(); //（4）注册事件。 onreadystatechange事件，状态改变时就会调用。 //如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 ajaxObj.onreadystatechange = function () &#123; // 为了保证 数据 完整返回，我们一般会判断 两个值 if (ajaxObj.readyState == 4 &amp;&amp; ajaxObj.status == 200) &#123; // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示 console.log('数据返回成功'); // 数据是保存在 异步对象的 属性中 console.log(ajaxObj.responseText); // 修改页面的显示 document.querySelector('h1').innerHTML = ajaxObj.responseText; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; post 请求举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 post 请求&lt;/h1&gt;&lt;input type="button" value="发送put_ajax请求" id='btnAjax'&gt;&lt;script type="text/javascript"&gt; // 异步对象 var xhr = new XMLHttpRequest(); // 设置属性 xhr.open('post', '02.post.php'); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); // 将数据通过send方法传递 xhr.send('name=fox&amp;age=18'); // 发送并接受返回值 xhr.onreadystatechange = function () &#123; // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; onreadystatechange 事件注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化） 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 事件的触发条件 事件的触发顺序 上图的参考链接： 你真的会使用XMLHttpRequest吗？ 实际开发中用的 原生Ajax请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var util = &#123;&#125;;//获取 ajax 请求之后的jsonutil.json = function (options) &#123; var opt = &#123; url: '', type: 'get', data: &#123;&#125;, success: function () &#123; &#125;, error: function () &#123; &#125;, &#125;; util.extend(opt, options); if (opt.url) &#123; //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject('Microsoft.XMLHTTP'); var data = opt.data, url = opt.url, type = opt.type.toUpperCase(); dataArr = []; &#125; for (var key in data) &#123; dataArr.push(key + '=' + data[key]); &#125; if (type === 'GET') &#123; url = url + '?' + dataArr.join('&amp;'); xhr.open(type, url.replace(/\?$/g, ''), true); xhr.send(); &#125; if (type === 'POST') &#123; xhr.open(type, url, true); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); xhr.send(dataArr.join('&amp;')); &#125; xhr.onload = function () &#123; if (xhr.status === 200 || xhr.status === 304) &#123; //304表示：用缓存即可。206表示获取媒体资源的前面一部分 var res; if (opt.success &amp;&amp; opt.success instanceof Function) &#123; res = xhr.responseText; if (typeof res === 'string') &#123; res = JSON.parse(res); //将字符串转成json opt.success.call(xhr, res); &#125; &#125; &#125; else &#123; if (opt.error &amp;&amp; opt.error instanceof Function) &#123; opt.error.call(xhr, res); &#125; &#125; &#125;;&#125; Ajax 的推荐链接：https://segmentfault.com/a/1190000006669043 跨域通信的几种方式方式如下： 1、JSONP 2、WebSocket 3、CORS 4、Hash 5、postMessage 上面这五种方式，在面试时，都要说出来。 1、JSONP面试会问：JSONP的原理是什么？怎么实现的？在CORS和postMessage以前，我们一直都是通过JSONP来做跨域通信的。JSONP的原理：通过&lt;script&gt;标签的异步加载来实现的。比如说，实际开发中，我们发现，head标签里，可以通过&lt;script&gt;标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。 JSONP的缺点： 1、安全问题(请求代码中可能存在安全隐患) 2、要确定jsonp请求是否失败并不容易 JSONP的实现： 比如说，客户端这样写： 1&lt;script src="http://www.Joyeux.com/?data=name&amp;callback=myjsonp"&gt;&lt;/script&gt; 上面的src中，data=name是get请求的参数，myjsonp是和后台约定好的函数名。服务器端这样写： 1234myjsonp(&#123; data: &#123;&#125;&#125;) 于是，本地要求创建一个myjsonp 的全局函数，才能将返回的数据执行出来。 实际开发中，前端的JSONP是这样实现的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script&gt; var util = &#123;&#125;; //定义方法：动态创建 script 标签 /** * [function 在页面中注入js脚本] * @param &#123;[type]&#125; url [description] * @param &#123;[type]&#125; charset [description] * @return &#123;[type]&#125; [description] */ util.createScript = function (url, charset) &#123; var script = document.createElement('script'); script.setAttribute('type', 'text/javascript'); charset &amp;&amp; script.setAttribute('charset', charset); script.setAttribute('src', url); script.async = true; return script; &#125;; /** 利用script标签的异步加载实现JSONP * [function 处理jsonp] * @param &#123;[type]&#125; url [description] * @param &#123;[type]&#125; onsucess [description] * @param &#123;[type]&#125; onerror [description] * @param &#123;[type]&#125; charset [description] * @return &#123;[type]&#125; [description] */ util.jsonp = function (url, onsuccess, onerror, charset) &#123; var callbackName = util.getName('tt_player'); //事先约定好的 函数名 window[callbackName] = function () &#123; //根据回调名称注册一个全局的函数 if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123; onsuccess(arguments[0]); &#125; &#125;; var script = util.createScript(url + '&amp;callback=' + callbackName, charset); //动态创建一个script标签 script.onload = script.onreadystatechange = function () &#123; //监听加载成功的事件，获取数据 if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123; script.onload = script.onreadystatechange = null; // 移除该script的 DOM 对象 if (script.parentNode) &#123; script.parentNode.removeChild(script); &#125; // 删除函数或变量 window[callbackName] = null; //最后不要忘了删除 &#125; &#125;; script.onerror = function () &#123; if (onerror &amp;&amp; util.isFunction(onerror)) &#123; onerror(); &#125; &#125;; // 发送GET请求 document.getElementsByTagName('head')[0].appendChild(script); //往html中增加这个标签，目的是把请求发送出去 &#125;;&lt;/script&gt; 2、WebSocketWebSocket的用法如下： 123456789101112131415161718192021//var ws = new WebSocket('wss://echo.websocket.org'); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。//把请求发出去ws.onopen = function (evt) &#123; console.log('Connection open ...'); ws.send('Hello WebSockets!');&#125;;//对方发消息过来时，我接收ws.onmessage = function (evt) &#123; console.log('Received Message: ', evt.data); ws.close();&#125;;//关闭连接ws.onclose = function (evt) &#123; console.log('Connection closed.');&#125;; Websocket的推荐链接：http://www.ruanyifeng.com/blog/2017/05/websocket.html 面试一般不会让你写这个代码，一般是考察你是否了解 WebSocket概念，知道有这么回事即可。 3、CORSCORS：一种跨域访问的机制，可以让AJAX实现跨域访问；CORS允许一个域上的网络应用向另一个域提交跨域AJAX请求。服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求．就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 fetch 是一个比较新的API，用来实现CORS通信。用法如下： 12345678// url（必选），options（可选）fetch('/some/url/', &#123; method: 'get',&#125;).then(function (response) &#123; //类似于 ES6中的promise&#125;).catch(function (err) &#123; // 出错了，等价于 then 的第二个参数，但这样更好用更直观&#125;); CORS的推荐链接：http://www.ruanyifeng.com/blog/2016/04/cors.html 推荐链接里有详细的配置。 另外，如果面试官问：“CORS为什么支持跨域的通信？” 答案：跨域时，浏览器会拦截Ajax请求，并在http头中加Origin。 4、Hashurl的#后面的内容就叫Hash。Hash的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。 补充：url的?后面的内容叫Search。Search的改变，会导致页面刷新，因此不能做跨域通信。 使用举例： 场景：我的页面 A 通过iframe或frame嵌入了跨域的页面 B。 现在，我这个A页面想给B页面发消息，怎么操作呢？ （1）首先，在我的A页面中： 123//伪代码var B = document.getElementsByTagName('iframe');B.src = B.src + '#' + 'jsonString'; //我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B （2）然后，在B页面中： 1234// B中的伪代码window.onhashchange = function () &#123; //通过onhashchange方法监听，url中的 hash 是否发生变化 var data = window.location.hash;&#125;; 5、postMessage()方法 window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源(可实现跨域)，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。 场景：窗口 A (http:A.com)向跨域的窗口 B (http:B.com)发送信息。步骤如下。 （1）在A窗口中操作如下：向B窗口发送数据： 12// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息 Bwindow.postMessage('data', 'http://B.com'); //这里强调的是B窗口里的window对象 （2）在B窗口中操作如下： 123456// 在窗口B中监听 message 事件Awindow.addEventListener('message', function (event) &#123; //这里强调的是A窗口里的window对象 console.log(event.origin); //获取 ：url。这里指：http://A.com console.log(event.source); //获取：A window对象 console.log(event.data); //获取传过来的数据&#125;, false);]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[CSS盒模型CSS盒模型的基本概念和分类CSS盒模型从内至外依次是content、padding、border、margin区域。分为标准盒模型和IE盒模型 标准盒模型标准盒子模型： 题目：谈一谈你对CSS盒模型的认识专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： （1）基本概念：content、padding、margin。 （2）标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人。 （3）CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 （4）JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 （5）实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 （6）BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论。 接下来，我们把上面的六条，依次讲解。 标准盒模型和IE盒子模型标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 CSS如何设置这两种模型代码如下： 12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高方式一：通过DOM节点的 style 样式获取1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型）1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的）1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。 此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷/margin重叠标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间如下图所示： 子元素和父元素之间1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。 BFC（边距重叠解决方案）BFC的概念BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理/BFC的布局规则【非常重要】BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： （1）BFC 内部的子元素，在垂直方向，边距会发生重叠。 （2）BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） （3）BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） （4）计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC有以下几种方法： 方法1：overflow: 不为vidible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex 参考链接： BFC原理详解 BFC详解 前端精选文摘：BFC 神奇背后的原理 下面来看几个例子，看看如何生成BFC。 BFC 的应用举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class="father"&gt; &lt;p class="son"&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class="father"&gt; &lt;p class="son" style="overflow: hidden"&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class="father-layout"&gt; &lt;div class="left"&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class="right"&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class="right" style="overflow: hidden"&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class="father"&gt; &lt;div class="son"&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算。 我的公众号想学习代码之外的软技能？不妨关注我的微信公众号：生命团队（id：vitateam）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Media-match插件解析]]></title>
    <url>%2F2018%2F01%2F10%2FMedia-match%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[插件介绍插件优点Media.match该插件主要来解决IE6-9等一些浏览器不支持媒体查询的情况，它会在浏览器不支持媒体查询时，就会重写window.matchMedia对象来实现媒体查询功能。 浏览器支持：测试IE 6-9，Chrome，Firefox，Opera，Safari，iOS和Android 功能支持：具有所有的基础知识+大多数规范 速度：在许多浏览器中，ops / sec可以与原生匹配媒体相媲美或超过本地匹配媒体。 大小：2.73KB缩小（1.46KB压缩） 媒体类型和功能支持 类型: all, screen, print, speech, projection, handheld, tv, braille, embossed, tty 宽度: width, min-width, max-width 高度: height, min-height, max-height 设备宽度: device-width, min-device-width, max-device-width 设备高度: device-height, min-device-height, max-device-height 纵横比: aspect-ratio, min-aspect-ratio, max-aspect-ratio 设备纵横比: device-aspect-ratio, min-device-aspect-ratio, max-device-aspect-ratio 方向: orientation 分辨率: resolution, min-resolution, max-resolution 设备像素比: device-pixel-ratio, min-device-pixel-ratio, max-device-pixel-ratio 颜色: color, min-color, max-color 色指数: color-index, min-color-index, max-color-index 缺乏支持 单色: monochrome, min-monochrome, max-monochrome 扫描: scan 网格: grid 插件生成的媒体查询对象浏览器不支持媒体查询时，该插件重写的window.matchMedia对象以及该对象所具有的属性、方法。1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var mql = window.matchMedia(&apos;screen and (color) and (orientation: landscape) and (min-width: 600px) and (min-height: 400px)&apos;); //console.log(mql); /* mql has the following properties: matches : &lt;Boolean&gt; media : &lt;String&gt; addListener : &lt;Function&gt; removeListener : &lt;Function&gt; */&lt;/script&gt; 12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.matchMedia(&apos;screen and (min-width: 600px) and (min-height: 400px), screen and (min-height: 400px)&apos;) .addListener(function(mql) &#123; if (mql.matches) &#123; // Media query does match &#125; else &#123; // Media query does not match anymore &#125; &#125;);&lt;/script&gt; 原生媒体查询对象当浏览器支持媒体查询时，window.matchMedia所具有的属性和方法。123456789101112131415161718192021222324&lt;script type=&quot;text/javascript&quot;&gt; if (window.matchMedia(&quot;(min-width: 400px)&quot;).matches) &#123; console.log(&apos;mql===&apos;, window.matchMedia(&quot;(min-width: 400px)&quot;)); /* mql has the following properties: matches : true &lt;Boolean&gt; media : &quot;(min-width: 400px)&quot; &lt;String&gt; addListener : &lt;Function&gt; removeListener : &lt;Function&gt; onchange : null ??? 暂不了解 */ &#125; else &#123; console.log(&apos;mql===&apos;, window.matchMedia(&quot;(min-width: 400px)&quot;)); /* mql has the following properties: matches : false &lt;Boolean&gt; media : &quot;(min-width: 400px)&quot; &lt;String&gt; addListener : &lt;Function&gt; removeListener : &lt;Function&gt; onchange : null ??? 暂不了解 */ &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JS插件</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[package.json字段详解]]></title>
    <url>%2F2018%2F01%2F09%2Fpackage-json%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述每个项目的根目录下面，一般都会有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息(比如名称、版本、许可证等元数据)。执行npm install命令会根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。package.json文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。注意：在该配置文件中不允许添加注释。 字段解析name(必需字段)当没有改配置项时，你的npm包就不会安装。名称和版本一起构成一个该npm包的唯一标识符。npm包的变化随着版本的变化而变化。 规则 该字段长度小于等于214个字符 该字段不能以点.或者下划线_开头 该字段不能包含大写字母 该字段最终成为URL的一部分、命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。 技巧 不要使用已发布的npm包名 不要在名称中加入.js或.node。???具体原因 名称尽量简短，因为它可能会作为require()的参数传递。 可以通过npm注册表，来检查该名称是否已经存在。 可以通过添加前缀来管理，比如@joyeux/mypackage。???具体细节 version(必需字段)当没有改配置项时，你的npm包就不会安装。名称和版本一起构成一个该npm包的唯一标识符。npm包的变化随着版本的变化而变化。 descriptionnpm包的描述，这是一个字符串，已列入npm search，有助于发现别人发现你的npm包。 keywordsnpm包的关键词，这是一个字符串，已列入npm search，有助于发现别人发现你的npm包。 homepage项目主页的地址。这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 bugsnpm包出现问题时的问题跟踪器或者向其报告问题的邮箱地址。npm bugs会使用这些信息。可以有两种表达形式：1234567//形式一&#123; &quot;url&quot; :&quot;http://github.com/owner/project/issues&quot;, &quot;email&quot; :&quot;project@hostname.com&quot;&#125;//形式二&quot;url&quot; :&quot;http://github.com/owner/project/issues&quot;, licensenpm包的许可证，便于人们知道他们如何被允许使用它，以及对它的任何限制。如果您使用的是MIT或者BSD-3-Clause等普通许可证，请为您使用的许可证添加当前的SPDX许可证标识符，如些所示：1&#123; &quot;license&quot; : &quot;MIT&quot; &#125; 如果您的npm包使用多个通用许可证，请使用SPDX许可证表达式语法版本2.0字符串，如下所示：1&#123; &quot;license&quot; : &quot;(ISC OR GPL-3.0)&quot; &#125; 如果您正在使用尚未分配SPDX标识符的许可证，或者正在使用自定义许可证，请使用如下所示的字符串值：12//filename位于npm包的根目录中&#123; &quot;license&quot; : &quot;SEE LICENSE IN &lt;filename&gt;&quot; &#125; 如果您不希望授予他人根据任何条款使用私人或未发布的软件包的权利：1&#123; &quot;license&quot;: &quot;UNLICENSED&quot; &#125; 考虑设置”private”: true以防止意外发表。 author, contributorsauthor是一个人，一个具有name属性的对象，contributors是一群人，一个具有name属性对象的数组。npm还会在您的npm用户信息中设置一个顶级“维护者(maintainers)”字段。如下所示：1234567891011121314151617//author&#123; &quot;name&quot; : &quot;Joyeux&quot;, &quot;email&quot; : &quot;949582554@qq.com&quot; &quot;url&quot; : &quot;https://joyeuxman.github.io/&quot;&#125;//contributors[&#123; &quot;name&quot; : &quot;Joyeux&quot;, &quot;email&quot; : &quot;949582554@qq.com&quot; &quot;url&quot; : &quot;https://joyeuxman.github.io/&quot;&#125;,&#123; &quot;name&quot; : &quot;Joyeux1&quot;, &quot;email&quot; : &quot;949582554@qq.com&quot; &quot;url&quot; : &quot;https://joyeuxman.github.io/&quot;&#125;] files项目包含的一组文件。如果是文件夹，文件夹下的文件也会被包含。如果需要把某些文件不包含在项目中，添加一个 .npmignore 文件(该文件位置可在npm包根目录)。这个文件和.gitignore类似。 main(建议必填)这个字段的值是你程序主入口的模块ID。 如果其他用户需要你的npm包，调用require()方法时，返回的就是这个模块的导出(exports); 如果发布为一个 NPM Package，则 require 为该属性指定的文件； 如果未指定该属性，则默认为根目录下的 index.js 或 index.node； binbin项用来指定各个内部命令(scripts配置项)对应的可执行文件的位置。123&quot;bin&quot;: &#123; &quot;someTool&quot;: &quot;./bin/someTool.js&quot;&#125; 上面代码指定，someTool命令对应的执行文件为bin子目录下的someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接node_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。因此，像下面这样的写法可以采用简写。1234567scripts: &#123; start: &apos;./node_modules/someTool/someTool.js build&apos;&#125;//简写为scripts: &#123; start: &apos;someTool build&apos;&#125; 所有node_modules/.bin/目录下的命令，都可以使用npm run [命令]的格式运行。在命令行下，键入npm run，然后按Enter键，就会显示所有可以使用的命令。 man通过指定一个字符串或一个数组一来让linux系统下的man命令查找文档地址。如果只有一个文件被指定的话，安装后直接执行man+模块名称，而不管man指定的文件的实际名称。例如:1234567//通过执行 man foo 命令会得到 ./man/doc.1 文件的内容。&#123; &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : &quot;./man/doc.1&quot;&#125; 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：1234567//会创建一些文件来作为man foo和man foo-bar命令的结果。&#123; &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]&#125; man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。1234567//会创建 man foo 和 man 2 foo 两条命令。&#123; &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]&#125; directoriesCommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件 ，可以发现里边有这个字段的内容。 directories.lib告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。 directories.bin如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。 directories.man指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。 directories.doc在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上） directories.example放一些示例脚本，或许某一天会有用 - -！ directories.test放一些测试脚本示例，或许某一天会有用 - -！ repository指定您的代码所在的地方。这对想要贡献的人有帮助。如果git仓库在GitHub上，那么这个npm docs 命令将能够找到你。1234&quot;repository&quot; : &#123; &quot;type&quot; : &quot;git&quot; , &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot; &#125; scriptsscripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。了解更多下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。123456&quot;scripts&quot;: &#123; &quot;preinstall&quot;: &quot;echo here it comes!&quot;, &quot;postinstall&quot;: &quot;echo there it goes!&quot;, &quot;start&quot;: &quot;node index.js&quot;, &quot;test&quot;: &quot;tap test/*.js&quot;&#125; config???暂不了解 dependenciesdependencies字段指定了项目运行所依赖的模块，指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。执行命令npm install xxx --save,会将xxx包写入到dependencies对象中。该对象中的包是生产环境所必需的。比如你需要引入第三方模块，比如underscore express等，则需要放入dependencies对象中(一般情况下在不影响系统性能的前提下，放入到该配置项的npm包越少越好)。对应的版本可以加上各种限定，主要有以下几种： 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本。 devDependenciesdevDependencies指定项目开发所需要的模块，指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。执行命令npm install xxx --save-dev,会将xxx包写入到devDependencies对象中。该对象中的包是开发环境所需要的，比如测试、编译、调试等不会影响自身功能的第三方模块，例如： css转换器(less/sass/less-loader等) JS转换器(babel系列包) 测试框架 打包工具(webpack/gulp/grunt) 代码检查(jsLint) …有待补充 peerDependencies有时你的项目和项目所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。例如：安装tea-latte插件1234567&#123; &quot;name&quot;: &quot;tea-latte&quot;, &quot;version&quot;: &quot;1.3.5&quot;, &quot;peerDependencies&quot;: &#123; &quot;tea&quot;: &quot;2.x&quot; &#125;&#125; 执行npm install tea-lattle12├── tea-latte@1.3.5└── tea@2.2.0 以上例子说明安装tea-lattle模块时，主程序tea必须 一起安装，而且tea的版本必须是2.x。如果你的项目指定的依赖是tea的3.0版本，就会报错。注意，从npm 3.0版开始，peerDependencies不再会默认安装了。 bundledDependencies一组包名，他们会在发布的时候被打包进去。如果您需要在本地保存npm包或通过单个文件下载使它们可用，则可以通过在bundledDependencies 数组中指定包名并执行，将包捆绑到tarball文件中npm pack。例子：1234567&#123; &quot;name&quot;: &quot;awesome-web-framework&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;bundledDependencies&quot;: [ &quot;renderized&quot;, &quot;super-streams&quot; ]&#125; 运行npm pack可以获得awesome-web-framework-1.0.0.tgz文件。这个文件包含了renderized和super-streams依赖。通过运行npm install awesome-web-framework-1.0.0.tgz命令可以获得这些依赖。 optionalDependencies如果可以使用依赖关系，但是如果npm无法找到或者无法安装，您可能会继续执行，那么您可以将其放入optionalDependencies 对象中。这是一个包名到版本或url的映射，就像 dependencies对象一样。不同之处在于构建失败不会导致安装失败。参赛作品optionalDependencies将覆盖同名作品 dependencies，所以通常最好只放在一个地方。 enginesengines字段可以指明了该模块运行的平台，比如 Node 的某个版本或者浏览器。1&#123; &quot;engines&quot; : &#123; &quot;node&quot; : &quot;&gt;=0.10.3 &lt;0.12&quot; &#125; &#125; 该字段也可以指定适用的npm版本。1&#123; &quot;engines&quot; : &#123; &quot;npm&quot; : &quot;~1.0.20&quot; &#125; &#125; 并且，像dependensies一样，如果你不指定版本或者指定“*”作为版本，那么所有版本的node都可以。如果指定一个“engines”字段，那么npm会需要node在里面，如果“engines”被省略，npm会假定它在node上工作。记住，除非用户设置engine-strict标记，这个字段只是建议值，只会在您的软件包作为依赖项安装时产生警告。 engineStrict在npm 3.0.0中删除了这个特性在npm 3.0.0之前，这个特性被用来处理这个包，就好像用户已经设置好一样engine-strict。它不再使用。 os你可以指定你的模块要运行在哪些操作系统中：1&quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ] 你也可以用黑名单代替白名单，在名字前面加上“!”就可以了：1&quot;os&quot; : [ &quot;!win32&quot; ] 操作系统用process.platform来探测。虽然没有很好地理由，但它是同时支持黑名单和白名单的。 cpu如果你的代码只能运行在特定的cpu架构下，你可以指定一个：1&quot;cpu&quot; : [ &quot;x64&quot;, &quot;ia32&quot; ] 就像os选项，你也可以黑一个架构：1&quot;cpu&quot; : [ &quot;!arm&quot;, &quot;!mips&quot; ] cpu架构用process.arch探测。 preferGlobal弃用该选项用于触发npm警告，但不会再发出警告。这纯粹是为了信息的目的。现在建议您尽可能将任何二进制文件安装为本地devDependencies。 private如果你设置”private”: true，npm就不会发布它。这是一个防止意外发布私有库的方式。如果你要确定给定的包是只发布在特定registry（如内部registry）的，用publishConfighash的描述来重写registry的publish-time配置参数。 publishConfig这是一个在发布时(publish-time)使用的配置集合。当你想设置tag或者registry的时候它非常有用，所以你可以确定一个给定的包没有打上“lastest”的tag或者被默认发布到全局的公开registry。任何配置都可以被重写，但当然可能只有“tag”和“registry”与发布的意图有关。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS异步加载浅析]]></title>
    <url>%2F2018%2F01%2F09%2FJS%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML页面渲染过程分析]]></title>
    <url>%2F2018%2F01%2F09%2FHTML%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[页面渲染概念浏览器渲染引擎的主要目的就是从一个网页的URL开始，经过一系列的复杂处理过程之后，变成一个可视化的结果，这一过程就是这里所说的页面渲染的基本过程。所谓的渲染，就是根据描述或者定义构建数学模型，通过模型生成图像的过程。浏览器的渲染引擎就是能够将HTML/CSS/JavaScript转换成图像结果的模块，如下图所示，输入是URL对应的各种资源，输出是可视化的图像。从这里看，非常的简单和容易理解。 浏览器渲染引擎那么渲染引擎提供了哪些功能模块来支持页面渲染的呢？下图是一个渲染引擎所包含的基本功能和它们依赖的一些第三方库。从图中大致可以看出，一个渲染引擎大致包括HTML解释器，CSS解释器，布局和JavaScript引擎。下面依次来描述它们：HTML解释器：解释HTML语言的解释器，本质是将HTML文本解释成DOM（文档对象模型）树。CSS解释器：解释样式表的解释器，其作用是将DOM中的各个元素对象加上样式信息，从而为计算最后结果的布局提供依据。布局：DOM之后，需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型。JavaScript引擎：JavaScript可以修改网页的内容，也能修改CSS的信息，JavaScript引擎解释JavaScript代码并把代码的逻辑和对DOM和CSS的改动信息应用到布局中去，从而改变渲染的结果。这些模块依赖很多其他的基础模块，这其中包括网络，存储，2D/3D图形，音频视频和图片解码器等。实际上，渲染引擎中还应该包括如何使用这些依赖模块的部分，这部分的工作其实并不少，因为需要使用它们来高效的渲染网页。例如，利用2D/3D图形库来实现高性能的网页绘制和网页的3D渲染，这个实现非常非常的复杂。最后，当然，在最下面，依然少不了操作系统的支持，例如线程支持，文件支持等等。 页面渲染基本过程绘制(painting) 根据HTML代码形成文档对象模型（DOM）。 加载并解析样式，形成CSS对象模型。 在文档对象模型和CSS对象模型之上，创建一棵由一组待生成渲染的对象组成的渲染树（在Webkit中这些对象被称为渲染器或渲染对象，而在Gecko中称之为“frame”。）渲染树反映了文档对象模型的结构，但是不包含诸如标签或含有display:none属性的不可见元素。在渲染树中，每一段文本字符串都表现为独立的渲染器。每一个渲染对象都包含与之对应的DOM对象，或者文本块，还加上计算过的样式。换言之，渲染树是一个文档对象模型的直观展示。 对渲染树上的每个元素，计算它的坐标，称之为布局。浏览器采用一种流方法，布局一个元素只需通过一次，但是表格元素需要通过多次。 渲染树上的元素最终展示在浏览器里，这一过程称为绘制(painting)。 当用户与网页交互，或者脚本程序改动修改网页时，前文提到的一些操作将会重复执行，因为网页的内在结构已经发生了改变。 重绘(repaint)当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。 重排(reflow)当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发： DOM操作（元素添加、删除、修改或者元素顺序的改变）； 内容变化，包括表单域内的文本改变； CSS属性的计算或改变； 添加或删除样式表； 更改“类”的属性； 浏览器窗口的操作（缩放，滚动）； 伪类激活（悬停）。 渲染引擎核心过程下面就是这些模块如何组织以达成渲染过程的。一般地，一个典型的渲染过程下图所示，这是渲染引擎的核心过程，下面逐个从左至右来解释上图中的这一过程。这一过程的先后关系由图中的实线箭头表示。左上角开始，首先是网页内容，送到HTML解释器。HTML解释器在解释它后形成DOM树，中间如果遇到JavaScript代码则交给JavaScript引擎去处理。如果页面包含CSS，则交给CSS解释器去解析。当DOM建立的时候，接受来自CSS解释的样式信息，构建一个新的内部绘图模型。该模型由布局模块计算模型内部的各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。最后解释图中虚线箭头的指向含义。它们表示在渲染过程中，每个阶段可能使用到的其他模块。在网页内容的下载中，需要使用到网络和存储，这个是显而易见地。但计算布局和绘图的时候，需要使用2D/3D的图形模块，同时因为要生成最后的可视化结果，这时候需要开始解码音频视频和图片，同其它内容一起绘制到最后的图像中。在渲染完成之后，用户可能需要跟渲染的结果进行交互，或者网页自身有动画，一般而言，这会持续的重新渲染过程。这个过程跟上面类似，不再赘述。 document.ready和window.onload事件doucument.ready事件由jQuery包装处理，在DOM结构加载完毕(不含图片、CSS等资源)之后触发。123456789101112&lt;!-- 方式一 --&gt;$(function()&#123; alert(&apos;DOM结构加载完毕，不含图片、CSS等资源&apos;);&#125;)&lt;!-- 方式二 --&gt;$(document).ready(function () &#123; alert(&apos;DOM结构加载完毕，不含图片、CSS等资源&apos;);&#125;)&lt;!-- 方式三 --&gt;$().ready(function () &#123; alert(&apos;DOM结构加载完毕，不含图片、CSS等资源&apos;);&#125;) window.onload事件为原生JS事件，在DOM结构完全加载完毕(包含图片、CSS等资源)之后触发。123window.onload = function () &#123; alert(&apos;页面资源加载完毕，包含图片、CSS资源&apos;); &#125;显而易见，document.ready事件早于window.onload事件。以下是一个例子，便于对其的理解。代码如下：1]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计者模式(张容铭)]]></title>
    <url>%2F2017%2F11%2F25%2Freading-note-1%2F</url>
    <content type="text"><![CDATA[问答通过this添加的属性和方法和同在prototype添加的属性和方法有什么不同? 通过this添加的属性和方法是在当前对象上添加的，然而JavaScript是一种基于原型prototype的语言，所以每创建一个对象(当然在JavaScript中函数也是一种对象)，它都有一个原型prototype用于指向其继承的属性、方法。这样通过prototype继承的方法和属性并不是对象自身的，所以在使用这些方法时，需要通过prototype一级一级查找来得到。这样你会发现通过this定义的属性和方法是该对象自身拥有的，所以我们每次通过类创建一个新对象时，this指向的属性和方法都会得到相应的创建，而通过prototype继承的属性或者方法时每个对象通过prototype访问到，所以我们每次通过类创建一个新对象时这些属性和方法不会再次创建。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模仿vue-elm项目心得]]></title>
    <url>%2F2017%2F11%2F05%2Fvue%2F</url>
    <content type="text"><![CDATA[源码以大多数人的努力程度之低，没必要拼天赋哟 技术栈vue2-webpack-vuex-vueRouter-flex-svg 问题 id=app、router-view标签为什么在根目录的index.html页面和App.vue文件中重复出现两次 代理的饿了吗后台好像不太稳定，有时候会出现请求失败，状态码为430 @import “@/style/mixin”报错(url-loader与webapck的alias是两种不同的url解析方式???) vue代码进行调试的时候，总感觉有些卡顿 router的模式为history的时候，会影响回退页面的滚动条的起始位置(样式异常),切换为hash模式就好了 目前发现v-bind指令可以将data返回的属性值绑定到标签属性上 目前发现v-on指令可以触发监听的函数方法1.methods对象中定义的函数方法2.原生DOM事件，如表单的submit动作，阻止表单的默认提交–&gt; v-on:submit.prevent vue知识点 hash与history两种模式的区别hash模式路由地址会带上#,但是浏览器发送给服务器的却是#之前的URL。hash模式的好处是，虽然你是个单页面应用，但是你可以只刷新当前页，而不必刷新整个单页面应用。history模式的话需要服务端配合，如果服务器配置仅仅是找不到对应的路由，就会重定向到index.html，那么刷新当前页会跳首页。如果服务器对于匹配不到URL不做配置，那么一般返回404页面。 v-for指令可用于遍历数组和对象。遍历数组时： (item,index) in arr遍历对象时： (value,key,index) in obj slot标签用于父组件向子组件分发想要显示的内容。使用场景:几个父组件公用一个子组件，且想要该子组件在不同的父组件中显示不同的内容。 v-model用于绑定表单控件元素，如input、textarea、select1.textarea/input[type=text]，将data返回的属性值双向绑定到input的value属性上2.input[type=checkbox]/input[type=radio]/select-optiona.以上元素有value属性时，将data返回的属性值双向绑定到input的value属性上b.以上元素无value属性时，将data返回的属性值双向绑定到以上元素是否被选中，选中为true，未选中为false v-if/v-show/slot标签都不会在文档排版中占位置，即不会像opacity样式那样占位置。 v-if与v-show区别v-show 会在app初始化的时候编译并且渲染，并且在之后一直存在。当切换v-show模块时，只是简单的更改css。v-if 当切换v-if模块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。 v-if 是惰性的，如果为false，则什么也不错-不编译，不渲染。 当第一次条件为真时，才开始编译。#####建议#####v-show的切换消耗比较低，但是不会重新渲染子组件，所以最好用于静态的内容或者不需要重新构建结构的组件。而 v-if 比较适合不太频繁的切换状态的组件。所以项目设计的时候，不要对复杂的业务设计模块太频繁的视图切换。尽量将静态内容和动态内容分离到不同的模块中。一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好 CSS font-zize:0(给inline、inline-block元素的父元素设置) 解决inline、inline-block元素之间的间距我们为了页面代码的整洁可读性，往往会设置一些适当的缩进、换行，但当元素的display为inline或者inline-block的时候，这些缩进、换行就会产生空白 JS document.defaultView属性返回当前document对象关联的window对象，如果没有，会返回null。IE9以下不支持。基本上用window.getComputedStyle()就可以了，只有一种情况必须用defaultView，就是firefox3.6上访问子框架内的样式(iframe) window.getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读。语法：var style = window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;);如果是伪类元素需要传递第二个参数，不是则传递null element.currentStylecurrentStyle是IE浏览器自娱自乐的一个属性，其与element.style可以说是近亲，至少在使用形式上类似，element.currentStyle，差别在于element.currentStyle返回的是元素当前应用的最终CSS属性值（包括外链CSS文件，页面中嵌入的属性等）。 element.scrollTop 属性可以设置或者获取一个元素被卷起的像素距离。一个元素的 scrollTop 是可以去计算出这个元素最高高度距离它容器顶部的可见高度。当一个元素的容器没有产生垂直方向的滚动条,那它的 scrollTop 的值默认为0. 冒泡(默认)false与捕获true1.一种事件触发方式 冒泡：子元素先触发冒泡，父元素次之。捕获：父元素先触发捕获，子元素次之2.两种事件触发方式混合点击子元素：父元素捕获–&gt;子元素冒泡–&gt;子元素捕获–&gt;父元素冒泡点击父元素：父元素冒泡–&gt;父元素捕获 addEventLister passive:true可以移动端解决滚动和触摸事件的卡顿 DOMContentLoaded与load事件的区别 插件 fastclick.js 处理移动端click事件300毫秒延迟1.为什么存在延迟从点击屏幕上的元素到触发元素的click事件，移动浏览器会有大约300毫秒的等待时间。为什么这么设计？因为它想想看看你是不是要进行双击（double tap）操作。2.不应用fastclick的场景a.桌面浏览器b.如果viewport meta标签中设置了 width=device-width，Android上的Chrome32+会禁用300ms延迟c.viewport meta 标签如果设置了user-scalable=no,Android上的Chrome(所有版本)都会禁用300ms延迟。d.IE10中，可以使用css属性 -ms-touch-action:none 禁止元素双击缩放 showdown.js 一个javascript环境下markdown语法解释工具 不足 需要系统学习一下svg 强化一下flex布局]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo之标签插件]]></title>
    <url>%2F2017%2F06%2F05%2Fnext%E4%B9%8B%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[引用文字语法可选参数：[author[, source]] [link] [source_link_title] [author[source]] [link] [source_link_title] 无参示例我永远相信只要永不放弃，我们还是有机会的。最后，我们还是坚信一点，这世界上只要有梦想，只要不断努力，只要不断学习，不管你长得如何，不管是这样，还是那样，男人的长相往往和他的的才华成反比。今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。 作者当你成功的时候，你说的所有话都是真理。 马云阿里巴巴 作者，链接很卑微，那就踮起脚尖。 @JoyeuxJoyeuxman.github.io 作者，链接，链接名称很卑微，那就踮起脚尖。 @Joyeux个人博客 引用代码块语法[title] [] [url] [link text]1可选参数：[title] [lang:language] [url] [link text] 普通的代码块1alert(&apos;Hello World!&apos;); 指定语言1[rectangle setX: 10 y: 10 width: 20 height: 20]; 附加说明Array.map1array.map(callback[, thisArg]) 附加说明和网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。[language] [title] [url] [link text] code snippet Pull Quote在文章中插入 Pull quote。content MD文件引入图片图片位于source/images/2.jpg1![md语法引入图片](/images/2.jpg) 使用img标签通过相对路径引入Image将post_asset_folder选项设置为true，会使md文件与其资源文件夹直接关联起来。图片位于source/_drafts/next值标签/images/next-标签.jpg1&lt;img src=&apos;./images/next-标签.jpg&apos;/&gt; Link在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。参数：text url [external] [title]百度一下，你就知道 Include Code插入source文件夹内的代码文件 引用文章引入其他文章的链接 引用资源引用文章的资源 Raw如果您想在文章中插入Swig标签，可以尝试使用Raw标签，以免解析异常 content]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
