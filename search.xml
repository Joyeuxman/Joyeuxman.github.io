<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Media-match插件解析]]></title>
    <url>%2F2018%2F01%2F10%2FMedia-match%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[插件介绍插件优点Media.match该插件主要来解决IE6-9等一些浏览器不支持媒体查询的情况，它会在浏览器不支持媒体查询时，就会重写window.matchMedia对象来实现媒体查询功能。 浏览器支持：测试IE 6-9，Chrome，Firefox，Opera，Safari，iOS和Android 功能支持：具有所有的基础知识+大多数规范 速度：在许多浏览器中，ops / sec可以与原生匹配媒体相媲美或超过本地匹配媒体。 大小：2.73KB缩小（1.46KB压缩） 媒体类型和功能支持 类型: all, screen, print, speech, projection, handheld, tv, braille, embossed, tty 宽度: width, min-width, max-width 高度: height, min-height, max-height 设备宽度: device-width, min-device-width, max-device-width 设备高度: device-height, min-device-height, max-device-height 纵横比: aspect-ratio, min-aspect-ratio, max-aspect-ratio 设备纵横比: device-aspect-ratio, min-device-aspect-ratio, max-device-aspect-ratio 方向: orientation 分辨率: resolution, min-resolution, max-resolution 设备像素比: device-pixel-ratio, min-device-pixel-ratio, max-device-pixel-ratio 颜色: color, min-color, max-color 色指数: color-index, min-color-index, max-color-index 缺乏支持 单色: monochrome, min-monochrome, max-monochrome 扫描: scan 网格: grid 插件生成的媒体查询对象浏览器不支持媒体查询时，该插件重写的window.matchMedia对象以及该对象所具有的属性、方法。1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var mql = window.matchMedia(&apos;screen and (color) and (orientation: landscape) and (min-width: 600px) and (min-height: 400px)&apos;); //console.log(mql); /* mql has the following properties: matches : &lt;Boolean&gt; media : &lt;String&gt; addListener : &lt;Function&gt; removeListener : &lt;Function&gt; */&lt;/script&gt; 12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.matchMedia(&apos;screen and (min-width: 600px) and (min-height: 400px), screen and (min-height: 400px)&apos;) .addListener(function(mql) &#123; if (mql.matches) &#123; // Media query does match &#125; else &#123; // Media query does not match anymore &#125; &#125;);&lt;/script&gt; 原生媒体查询对象当浏览器支持媒体查询时，window.matchMedia所具有的属性和方法。123456789101112131415161718192021222324&lt;script type=&quot;text/javascript&quot;&gt; if (window.matchMedia(&quot;(min-width: 400px)&quot;).matches) &#123; console.log(&apos;mql===&apos;, window.matchMedia(&quot;(min-width: 400px)&quot;)); /* mql has the following properties: matches : true &lt;Boolean&gt; media : &quot;(min-width: 400px)&quot; &lt;String&gt; addListener : &lt;Function&gt; removeListener : &lt;Function&gt; onchange : null ??? 暂不了解 */ &#125; else &#123; console.log(&apos;mql===&apos;, window.matchMedia(&quot;(min-width: 400px)&quot;)); /* mql has the following properties: matches : false &lt;Boolean&gt; media : &quot;(min-width: 400px)&quot; &lt;String&gt; addListener : &lt;Function&gt; removeListener : &lt;Function&gt; onchange : null ??? 暂不了解 */ &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JS插件</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[package.json字段详解]]></title>
    <url>%2F2018%2F01%2F09%2Fpackage-json%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述每个项目的根目录下面，一般都会有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息(比如名称、版本、许可证等元数据)。执行npm install命令会根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。package.json文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。注意：在该配置文件中不允许添加注释。 字段解析name(必需字段)当没有改配置项时，你的npm包就不会安装。名称和版本一起构成一个该npm包的唯一标识符。npm包的变化随着版本的变化而变化。 规则 该字段长度小于等于214个字符 该字段不能以点.或者下划线_开头 该字段不能包含大写字母 该字段最终成为URL的一部分、命令行中的参数以及文件夹名称。因此，该名称不能包含任何非URL安全字符。 技巧 不要使用已发布的npm包名 不要在名称中加入.js或.node。???具体原因 名称尽量简短，因为它可能会作为require()的参数传递。 可以通过npm注册表，来检查该名称是否已经存在。 可以通过添加前缀来管理，比如@joyeux/mypackage。???具体细节 version(必需字段)当没有改配置项时，你的npm包就不会安装。名称和版本一起构成一个该npm包的唯一标识符。npm包的变化随着版本的变化而变化。 descriptionnpm包的描述，这是一个字符串，已列入npm search，有助于发现别人发现你的npm包。 keywordsnpm包的关键词，这是一个字符串，已列入npm search，有助于发现别人发现你的npm包。 homepage项目主页的地址。这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 bugsnpm包出现问题时的问题跟踪器或者向其报告问题的邮箱地址。npm bugs会使用这些信息。可以有两种表达形式：1234567//形式一&#123; &quot;url&quot; :&quot;http://github.com/owner/project/issues&quot;, &quot;email&quot; :&quot;project@hostname.com&quot;&#125;//形式二&quot;url&quot; :&quot;http://github.com/owner/project/issues&quot;, licensenpm包的许可证，便于人们知道他们如何被允许使用它，以及对它的任何限制。如果您使用的是MIT或者BSD-3-Clause等普通许可证，请为您使用的许可证添加当前的SPDX许可证标识符，如些所示：1&#123; &quot;license&quot; : &quot;MIT&quot; &#125; 如果您的npm包使用多个通用许可证，请使用SPDX许可证表达式语法版本2.0字符串，如下所示：1&#123; &quot;license&quot; : &quot;(ISC OR GPL-3.0)&quot; &#125; 如果您正在使用尚未分配SPDX标识符的许可证，或者正在使用自定义许可证，请使用如下所示的字符串值：12//filename位于npm包的根目录中&#123; &quot;license&quot; : &quot;SEE LICENSE IN &lt;filename&gt;&quot; &#125; 如果您不希望授予他人根据任何条款使用私人或未发布的软件包的权利：1&#123; &quot;license&quot;: &quot;UNLICENSED&quot; &#125; 考虑设置”private”: true以防止意外发表。 author, contributorsauthor是一个人，一个具有name属性的对象，contributors是一群人，一个具有name属性对象的数组。npm还会在您的npm用户信息中设置一个顶级“维护者(maintainers)”字段。如下所示：1234567891011121314151617//author&#123; &quot;name&quot; : &quot;Joyeux&quot;, &quot;email&quot; : &quot;949582554@qq.com&quot; &quot;url&quot; : &quot;https://joyeuxman.github.io/&quot;&#125;//contributors[&#123; &quot;name&quot; : &quot;Joyeux&quot;, &quot;email&quot; : &quot;949582554@qq.com&quot; &quot;url&quot; : &quot;https://joyeuxman.github.io/&quot;&#125;,&#123; &quot;name&quot; : &quot;Joyeux1&quot;, &quot;email&quot; : &quot;949582554@qq.com&quot; &quot;url&quot; : &quot;https://joyeuxman.github.io/&quot;&#125;] files项目包含的一组文件。如果是文件夹，文件夹下的文件也会被包含。如果需要把某些文件不包含在项目中，添加一个 .npmignore 文件(该文件位置可在npm包根目录)。这个文件和.gitignore类似。 main(建议必填)这个字段的值是你程序主入口的模块ID。 如果其他用户需要你的npm包，调用require()方法时，返回的就是这个模块的导出(exports); 如果发布为一个 NPM Package，则 require 为该属性指定的文件； 如果未指定该属性，则默认为根目录下的 index.js 或 index.node； binbin项用来指定各个内部命令(scripts配置项)对应的可执行文件的位置。123&quot;bin&quot;: &#123; &quot;someTool&quot;: &quot;./bin/someTool.js&quot;&#125; 上面代码指定，someTool命令对应的执行文件为bin子目录下的someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接node_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。因此，像下面这样的写法可以采用简写。1234567scripts: &#123; start: &apos;./node_modules/someTool/someTool.js build&apos;&#125;//简写为scripts: &#123; start: &apos;someTool build&apos;&#125; 所有node_modules/.bin/目录下的命令，都可以使用npm run [命令]的格式运行。在命令行下，键入npm run，然后按Enter键，就会显示所有可以使用的命令。 man通过指定一个字符串或一个数组一来让linux系统下的man命令查找文档地址。如果只有一个文件被指定的话，安装后直接执行man+模块名称，而不管man指定的文件的实际名称。例如:1234567//通过执行 man foo 命令会得到 ./man/doc.1 文件的内容。&#123; &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : &quot;./man/doc.1&quot;&#125; 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：1234567//会创建一些文件来作为man foo和man foo-bar命令的结果。&#123; &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]&#125; man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。1234567//会创建 man foo 和 man 2 foo 两条命令。&#123; &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]&#125; directoriesCommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件 ，可以发现里边有这个字段的内容。 directories.lib告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。 directories.bin如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。 directories.man指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。 directories.doc在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上） directories.example放一些示例脚本，或许某一天会有用 - -！ directories.test放一些测试脚本示例，或许某一天会有用 - -！ repository指定您的代码所在的地方。这对想要贡献的人有帮助。如果git仓库在GitHub上，那么这个npm docs 命令将能够找到你。1234&quot;repository&quot; : &#123; &quot;type&quot; : &quot;git&quot; , &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot; &#125; scriptsscripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。了解更多下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。123456&quot;scripts&quot;: &#123; &quot;preinstall&quot;: &quot;echo here it comes!&quot;, &quot;postinstall&quot;: &quot;echo there it goes!&quot;, &quot;start&quot;: &quot;node index.js&quot;, &quot;test&quot;: &quot;tap test/*.js&quot;&#125; config???暂不了解 dependenciesdependencies字段指定了项目运行所依赖的模块，指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。执行命令npm install xxx --save,会将xxx包写入到dependencies对象中。该对象中的包是生产环境所必需的。比如你需要引入第三方模块，比如underscore express等，则需要放入dependencies对象中(一般情况下在不影响系统性能的前提下，放入到该配置项的npm包越少越好)。对应的版本可以加上各种限定，主要有以下几种： 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本。 devDependenciesdevDependencies指定项目开发所需要的模块，指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。执行命令npm install xxx --save-dev,会将xxx包写入到devDependencies对象中。该对象中的包是开发环境所需要的，比如测试、编译、调试等不会影响自身功能的第三方模块，例如： css转换器(less/sass/less-loader等) JS转换器(babel系列包) 测试框架 打包工具(webpack/gulp/grunt) 代码检查(jsLint) …有待补充 peerDependencies有时你的项目和项目所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。例如：安装tea-latte插件1234567&#123; &quot;name&quot;: &quot;tea-latte&quot;, &quot;version&quot;: &quot;1.3.5&quot;, &quot;peerDependencies&quot;: &#123; &quot;tea&quot;: &quot;2.x&quot; &#125;&#125; 执行npm install tea-lattle12├── tea-latte@1.3.5└── tea@2.2.0 以上例子说明安装tea-lattle模块时，主程序tea必须 一起安装，而且tea的版本必须是2.x。如果你的项目指定的依赖是tea的3.0版本，就会报错。注意，从npm 3.0版开始，peerDependencies不再会默认安装了。 bundledDependencies一组包名，他们会在发布的时候被打包进去。如果您需要在本地保存npm包或通过单个文件下载使它们可用，则可以通过在bundledDependencies 数组中指定包名并执行，将包捆绑到tarball文件中npm pack。例子：1234567&#123; &quot;name&quot;: &quot;awesome-web-framework&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;bundledDependencies&quot;: [ &quot;renderized&quot;, &quot;super-streams&quot; ]&#125; 运行npm pack可以获得awesome-web-framework-1.0.0.tgz文件。这个文件包含了renderized和super-streams依赖。通过运行npm install awesome-web-framework-1.0.0.tgz命令可以获得这些依赖。 optionalDependencies如果可以使用依赖关系，但是如果npm无法找到或者无法安装，您可能会继续执行，那么您可以将其放入optionalDependencies 对象中。这是一个包名到版本或url的映射，就像 dependencies对象一样。不同之处在于构建失败不会导致安装失败。参赛作品optionalDependencies将覆盖同名作品 dependencies，所以通常最好只放在一个地方。 enginesengines字段可以指明了该模块运行的平台，比如 Node 的某个版本或者浏览器。1&#123; &quot;engines&quot; : &#123; &quot;node&quot; : &quot;&gt;=0.10.3 &lt;0.12&quot; &#125; &#125; 该字段也可以指定适用的npm版本。1&#123; &quot;engines&quot; : &#123; &quot;npm&quot; : &quot;~1.0.20&quot; &#125; &#125; 并且，像dependensies一样，如果你不指定版本或者指定“*”作为版本，那么所有版本的node都可以。如果指定一个“engines”字段，那么npm会需要node在里面，如果“engines”被省略，npm会假定它在node上工作。记住，除非用户设置engine-strict标记，这个字段只是建议值，只会在您的软件包作为依赖项安装时产生警告。 engineStrict在npm 3.0.0中删除了这个特性在npm 3.0.0之前，这个特性被用来处理这个包，就好像用户已经设置好一样engine-strict。它不再使用。 os你可以指定你的模块要运行在哪些操作系统中：1&quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ] 你也可以用黑名单代替白名单，在名字前面加上“!”就可以了：1&quot;os&quot; : [ &quot;!win32&quot; ] 操作系统用process.platform来探测。虽然没有很好地理由，但它是同时支持黑名单和白名单的。 cpu如果你的代码只能运行在特定的cpu架构下，你可以指定一个：1&quot;cpu&quot; : [ &quot;x64&quot;, &quot;ia32&quot; ] 就像os选项，你也可以黑一个架构：1&quot;cpu&quot; : [ &quot;!arm&quot;, &quot;!mips&quot; ] cpu架构用process.arch探测。 preferGlobal弃用该选项用于触发npm警告，但不会再发出警告。这纯粹是为了信息的目的。现在建议您尽可能将任何二进制文件安装为本地devDependencies。 private如果你设置”private”: true，npm就不会发布它。这是一个防止意外发布私有库的方式。如果你要确定给定的包是只发布在特定registry（如内部registry）的，用publishConfighash的描述来重写registry的publish-time配置参数。 publishConfig这是一个在发布时(publish-time)使用的配置集合。当你想设置tag或者registry的时候它非常有用，所以你可以确定一个给定的包没有打上“lastest”的tag或者被默认发布到全局的公开registry。任何配置都可以被重写，但当然可能只有“tag”和“registry”与发布的意图有关。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS异步加载浅析]]></title>
    <url>%2F2018%2F01%2F09%2FJS%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML页面渲染过程分析]]></title>
    <url>%2F2018%2F01%2F09%2FHTML%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[页面渲染概念浏览器渲染引擎的主要目的就是从一个网页的URL开始，经过一系列的复杂处理过程之后，变成一个可视化的结果，这一过程就是这里所说的页面渲染的基本过程。所谓的渲染，就是根据描述或者定义构建数学模型，通过模型生成图像的过程。浏览器的渲染引擎就是能够将HTML/CSS/JavaScript转换成图像结果的模块，如下图所示，输入是URL对应的各种资源，输出是可视化的图像。从这里看，非常的简单和容易理解。 浏览器渲染引擎那么渲染引擎提供了哪些功能模块来支持页面渲染的呢？下图是一个渲染引擎所包含的基本功能和它们依赖的一些第三方库。从图中大致可以看出，一个渲染引擎大致包括HTML解释器，CSS解释器，布局和JavaScript引擎。下面依次来描述它们：HTML解释器：解释HTML语言的解释器，本质是将HTML文本解释成DOM（文档对象模型）树。CSS解释器：解释样式表的解释器，其作用是将DOM中的各个元素对象加上样式信息，从而为计算最后结果的布局提供依据。布局：DOM之后，需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型。JavaScript引擎：JavaScript可以修改网页的内容，也能修改CSS的信息，JavaScript引擎解释JavaScript代码并把代码的逻辑和对DOM和CSS的改动信息应用到布局中去，从而改变渲染的结果。这些模块依赖很多其他的基础模块，这其中包括网络，存储，2D/3D图形，音频视频和图片解码器等。实际上，渲染引擎中还应该包括如何使用这些依赖模块的部分，这部分的工作其实并不少，因为需要使用它们来高效的渲染网页。例如，利用2D/3D图形库来实现高性能的网页绘制和网页的3D渲染，这个实现非常非常的复杂。最后，当然，在最下面，依然少不了操作系统的支持，例如线程支持，文件支持等等。 页面渲染基本过程绘制(painting) 根据HTML代码形成文档对象模型（DOM）。 加载并解析样式，形成CSS对象模型。 在文档对象模型和CSS对象模型之上，创建一棵由一组待生成渲染的对象组成的渲染树（在Webkit中这些对象被称为渲染器或渲染对象，而在Gecko中称之为“frame”。）渲染树反映了文档对象模型的结构，但是不包含诸如标签或含有display:none属性的不可见元素。在渲染树中，每一段文本字符串都表现为独立的渲染器。每一个渲染对象都包含与之对应的DOM对象，或者文本块，还加上计算过的样式。换言之，渲染树是一个文档对象模型的直观展示。 对渲染树上的每个元素，计算它的坐标，称之为布局。浏览器采用一种流方法，布局一个元素只需通过一次，但是表格元素需要通过多次。 渲染树上的元素最终展示在浏览器里，这一过程称为绘制(painting)。 当用户与网页交互，或者脚本程序改动修改网页时，前文提到的一些操作将会重复执行，因为网页的内在结构已经发生了改变。 重绘(repaint)当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。 重排(reflow)当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发： DOM操作（元素添加、删除、修改或者元素顺序的改变）； 内容变化，包括表单域内的文本改变； CSS属性的计算或改变； 添加或删除样式表； 更改“类”的属性； 浏览器窗口的操作（缩放，滚动）； 伪类激活（悬停）。 渲染引擎核心过程下面就是这些模块如何组织以达成渲染过程的。一般地，一个典型的渲染过程下图所示，这是渲染引擎的核心过程，下面逐个从左至右来解释上图中的这一过程。这一过程的先后关系由图中的实线箭头表示。左上角开始，首先是网页内容，送到HTML解释器。HTML解释器在解释它后形成DOM树，中间如果遇到JavaScript代码则交给JavaScript引擎去处理。如果页面包含CSS，则交给CSS解释器去解析。当DOM建立的时候，接受来自CSS解释的样式信息，构建一个新的内部绘图模型。该模型由布局模块计算模型内部的各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。最后解释图中虚线箭头的指向含义。它们表示在渲染过程中，每个阶段可能使用到的其他模块。在网页内容的下载中，需要使用到网络和存储，这个是显而易见地。但计算布局和绘图的时候，需要使用2D/3D的图形模块，同时因为要生成最后的可视化结果，这时候需要开始解码音频视频和图片，同其它内容一起绘制到最后的图像中。在渲染完成之后，用户可能需要跟渲染的结果进行交互，或者网页自身有动画，一般而言，这会持续的重新渲染过程。这个过程跟上面类似，不再赘述。 document.ready和window.onload事件doucument.ready事件由jQuery包装处理，在DOM结构加载完毕(不含图片、CSS等资源)之后触发。123456789101112&lt;!-- 方式一 --&gt;$(function()&#123; alert(&apos;DOM结构加载完毕，不含图片、CSS等资源&apos;);&#125;)&lt;!-- 方式二 --&gt;$(document).ready(function () &#123; alert(&apos;DOM结构加载完毕，不含图片、CSS等资源&apos;);&#125;)&lt;!-- 方式三 --&gt;$().ready(function () &#123; alert(&apos;DOM结构加载完毕，不含图片、CSS等资源&apos;);&#125;) window.onload事件为原生JS事件，在DOM结构完全加载完毕(包含图片、CSS等资源)之后触发。123window.onload = function () &#123; alert(&apos;页面资源加载完毕，包含图片、CSS资源&apos;); &#125;显而易见，document.ready事件早于window.onload事件。以下是一个例子，便于对其的理解。代码如下：1]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计者模式(张容铭)]]></title>
    <url>%2F2017%2F11%2F25%2Freading-note-1%2F</url>
    <content type="text"><![CDATA[问答通过this添加的属性和方法和同在prototype添加的属性和方法有什么不同? 通过this添加的属性和方法是在当前对象上添加的，然而JavaScript是一种基于原型prototype的语言，所以每创建一个对象(当然在JavaScript中函数也是一种对象)，它都有一个原型prototype用于指向其继承的属性、方法。这样通过prototype继承的方法和属性并不是对象自身的，所以在使用这些方法时，需要通过prototype一级一级查找来得到。这样你会发现通过this定义的属性和方法是该对象自身拥有的，所以我们每次通过类创建一个新对象时，this指向的属性和方法都会得到相应的创建，而通过prototype继承的属性或者方法时每个对象通过prototype访问到，所以我们每次通过类创建一个新对象时这些属性和方法不会再次创建。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模仿vue-elm项目心得]]></title>
    <url>%2F2017%2F11%2F05%2Fvue%2F</url>
    <content type="text"><![CDATA[源码以大多数人的努力程度之低，没必要拼天赋哟 技术栈vue2-webpack-vuex-vueRouter-flex-svg 问题 id=app、router-view标签为什么在根目录的index.html页面和App.vue文件中重复出现两次 代理的饿了吗后台好像不太稳定，有时候会出现请求失败，状态码为430 @import “@/style/mixin”报错(url-loader与webapck的alias是两种不同的url解析方式???) vue代码进行调试的时候，总感觉有些卡顿 router的模式为history的时候，会影响回退页面的滚动条的起始位置(样式异常),切换为hash模式就好了 目前发现v-bind指令可以将data返回的属性值绑定到标签属性上 目前发现v-on指令可以触发监听的函数方法1.methods对象中定义的函数方法2.原生DOM事件，如表单的submit动作，阻止表单的默认提交–&gt; v-on:submit.prevent vue知识点 hash与history两种模式的区别hash模式路由地址会带上#,但是浏览器发送给服务器的却是#之前的URL。hash模式的好处是，虽然你是个单页面应用，但是你可以只刷新当前页，而不必刷新整个单页面应用。history模式的话需要服务端配合，如果服务器配置仅仅是找不到对应的路由，就会重定向到index.html，那么刷新当前页会跳首页。如果服务器对于匹配不到URL不做配置，那么一般返回404页面。 v-for指令可用于遍历数组和对象。遍历数组时： (item,index) in arr遍历对象时： (value,key,index) in obj slot标签用于父组件向子组件分发想要显示的内容。使用场景:几个父组件公用一个子组件，且想要该子组件在不同的父组件中显示不同的内容。 v-model用于绑定表单控件元素，如input、textarea、select1.textarea/input[type=text]，将data返回的属性值双向绑定到input的value属性上2.input[type=checkbox]/input[type=radio]/select-optiona.以上元素有value属性时，将data返回的属性值双向绑定到input的value属性上b.以上元素无value属性时，将data返回的属性值双向绑定到以上元素是否被选中，选中为true，未选中为false v-if/v-show/slot标签都不会在文档排版中占位置，即不会像opacity样式那样占位置。 v-if与v-show区别v-show 会在app初始化的时候编译并且渲染，并且在之后一直存在。当切换v-show模块时，只是简单的更改css。v-if 当切换v-if模块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。 v-if 是惰性的，如果为false，则什么也不错-不编译，不渲染。 当第一次条件为真时，才开始编译。#####建议#####v-show的切换消耗比较低，但是不会重新渲染子组件，所以最好用于静态的内容或者不需要重新构建结构的组件。而 v-if 比较适合不太频繁的切换状态的组件。所以项目设计的时候，不要对复杂的业务设计模块太频繁的视图切换。尽量将静态内容和动态内容分离到不同的模块中。一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好 CSS font-zize:0(给inline、inline-block元素的父元素设置) 解决inline、inline-block元素之间的间距我们为了页面代码的整洁可读性，往往会设置一些适当的缩进、换行，但当元素的display为inline或者inline-block的时候，这些缩进、换行就会产生空白 JS document.defaultView属性返回当前document对象关联的window对象，如果没有，会返回null。IE9以下不支持。基本上用window.getComputedStyle()就可以了，只有一种情况必须用defaultView，就是firefox3.6上访问子框架内的样式(iframe) window.getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读。语法：var style = window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;);如果是伪类元素需要传递第二个参数，不是则传递null element.currentStylecurrentStyle是IE浏览器自娱自乐的一个属性，其与element.style可以说是近亲，至少在使用形式上类似，element.currentStyle，差别在于element.currentStyle返回的是元素当前应用的最终CSS属性值（包括外链CSS文件，页面中嵌入的属性等）。 element.scrollTop 属性可以设置或者获取一个元素被卷起的像素距离。一个元素的 scrollTop 是可以去计算出这个元素最高高度距离它容器顶部的可见高度。当一个元素的容器没有产生垂直方向的滚动条,那它的 scrollTop 的值默认为0. 冒泡(默认)false与捕获true1.一种事件触发方式 冒泡：子元素先触发冒泡，父元素次之。捕获：父元素先触发捕获，子元素次之2.两种事件触发方式混合点击子元素：父元素捕获–&gt;子元素冒泡–&gt;子元素捕获–&gt;父元素冒泡点击父元素：父元素冒泡–&gt;父元素捕获 addEventLister passive:true可以移动端解决滚动和触摸事件的卡顿 DOMContentLoaded与load事件的区别 插件 fastclick.js 处理移动端click事件300毫秒延迟1.为什么存在延迟从点击屏幕上的元素到触发元素的click事件，移动浏览器会有大约300毫秒的等待时间。为什么这么设计？因为它想想看看你是不是要进行双击（double tap）操作。2.不应用fastclick的场景a.桌面浏览器b.如果viewport meta标签中设置了 width=device-width，Android上的Chrome32+会禁用300ms延迟c.viewport meta 标签如果设置了user-scalable=no,Android上的Chrome(所有版本)都会禁用300ms延迟。d.IE10中，可以使用css属性 -ms-touch-action:none 禁止元素双击缩放 showdown.js 一个javascript环境下markdown语法解释工具 不足 需要系统学习一下svg 强化一下flex布局]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo之标签插件]]></title>
    <url>%2F2017%2F06%2F05%2Fnext%E4%B9%8B%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[引用文字语法可选参数：[author[, source]] [link] [source_link_title] [author[source]] [link] [source_link_title] 无参示例我永远相信只要永不放弃，我们还是有机会的。最后，我们还是坚信一点，这世界上只要有梦想，只要不断努力，只要不断学习，不管你长得如何，不管是这样，还是那样，男人的长相往往和他的的才华成反比。今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。 作者当你成功的时候，你说的所有话都是真理。 马云阿里巴巴 作者，链接很卑微，那就踮起脚尖。 @JoyeuxJoyeuxman.github.io 作者，链接，链接名称很卑微，那就踮起脚尖。 @Joyeux个人博客 引用代码块语法[title] [] [url] [link text]1可选参数：[title] [lang:language] [url] [link text] 普通的代码块1alert(&apos;Hello World!&apos;); 指定语言1[rectangle setX: 10 y: 10 width: 20 height: 20]; 附加说明Array.map1array.map(callback[, thisArg]) 附加说明和网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。[language] [title] [url] [link text] code snippet Pull Quote在文章中插入 Pull quote。content MD文件引入图片图片位于source/images/2.jpg1![md语法引入图片](/images/2.jpg) 使用img标签通过相对路径引入Image将post_asset_folder选项设置为true，会使md文件与其资源文件夹直接关联起来。图片位于source/_drafts/next值标签/images/next-标签.jpg1&lt;img src=&apos;./images/next-标签.jpg&apos;/&gt; Link在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。参数：text url [external] [title]百度一下，你就知道 Include Code插入source文件夹内的代码文件 引用文章引入其他文章的链接 引用资源引用文章的资源 Raw如果您想在文章中插入Swig标签，可以尝试使用Raw标签，以免解析异常 content]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
